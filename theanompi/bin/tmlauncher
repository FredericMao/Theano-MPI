#!/bin/bash

# The Theano-MPI launcher

# use shell to launch mpirun directly to avoid additional python process


##################
#################
# parsing configs
#################
##################

RED='\e[1;31m'
NC='\e[0m' # No Color

python -c "import theanompi"
if [[ $? ]]
then
	echo 'Found Theano-MPI in:'
	theanompipath=$(python -c "import theanompi;print theanompi.__path__[0]")
	echo $theanompipath
else
	echo -e "${RED}Error${NC}: Theano-MPI not found"
	exit 1
fi


for i in "$@"
do
case $i in
    -cfg=*|--config=*)
	    CONFIG="${i#*=}"
    ;;
    -file=*|--modelfile=*)
	    MODELFILE="${i#*=}"
    ;;
    -class=*|--modelclass=*)
	    MODELCLASS="${i#*=}"
    ;;
	-r=*|--rule=*)
		RULE="${i#*=}"
	;;
	-s=*|--size=*)
		SIZE="${i#*=}"
	;;
	-bsp_sync_type=*)
		BSP_SYNC_TYPE="${i#*=}"
	;;
	-bsp_exch_strategy=*)
		BSP_EXCH_STRATEGY="${i#*=}"
	;;
	-b|-bind)
		BIND='True'
	;;
    *)
        # unknown option
		echo -e "${RED}Error${NC}: unknown option ${i}"
		exit 1
    ;;
esac
done

CONFIG=${CONFIG}
MODELFILE=${MODELFILE}
MODELCLASS=${MODELCLASS}
RULE=${RULE}

if [[ (-z $CONFIG) && (-z $MODELFILE) && (-z $MODELCLASS) && (-z $RULE) ]]
then
	echo -e "${RED}Error${NC}: Neither config nor run options provided"
	exit 1
elif [[ ! -z $CONFIG ]]
then
	# if config file provided, RULE, MODELFILE and MODELCLASS will be overwritten
	echo
	echo 'config file provided:'
	source $CONFIG
	echo "RULE = $RULE"
	echo "MODELFILE = $MODELFILE"
	echo "MODELCLASS = $MODELCLASS"
	echo "SIZE = $SIZE"
fi

if [[ -z $MODELFILE ]]; then
	echo -e "${RED}Error${NC}: NO modelfile provided"
	exit 1
fi

if [[ -z $MODELCLASS ]]; then
	echo -e "${RED}Error${NC}: NO modelclass provided"
	exit 1
fi

if [[ -z $RULE ]]; then
	echo -e "${RED}Error${NC}: NO rule provided"
	exit 1
fi

##############################
##############################
# Verifying device on hardware
# Getting device array 
# Getting cpu-affinity array corresponding to device array
##############################
##############################
function range_expand
{
    IFS=,
    set -- $1
    n=$#
    for element; do
        if [[ $element =~ ^(-?[0-9]+)-(-?[0-9]+)$ ]]; then
            set -- "$@" $(eval echo "{${BASH_REMATCH[1]}..${BASH_REMATCH[2]}}")
        else
            set -- "$@" $element
        fi
    done
    shift $n
    # echo "$@"
	echo "${*// /,}"
    # to return a comma-separated value: 
}

function get_cpu_dev_list
{
	BIND=$1
	# generate a devarray according to DEVICES or SIZE
	if [[ -z $DEVICES && -z $SIZE ]]
	then
		echo -e "${RED}Error${NC}: Neither DEVICES nor SIZE is specified"
		exit 1
	elif [[ ! -z $DEVICES ]]
	then
		set -f
		devarray=(${DEVICES//,/ }) # a comma delimited string of device names
		
		if [[ ! -z $SIZE && ${#devarray[@]} -ne ${SIZE} ]]
		then
			echo -e "${RED}Error${NC}: the length of device list (${#devarray[@]}) does not match the specified size (${SIZE})"
			exit 1
		else
			SIZE=${#devarray[@]}
		fi		
	elif [[ ! -z $SIZE && -z $DEVICES ]]
	then
		devarray=()
		for (( i=0; i<$SIZE; i++))
		do
			devarray+=("cuda$i")
		done
	fi
	
	cpulist=($(nvidia-smi topo -m | sed -n -e 's/^.*\s\+\([0-9,-]\+\)$/\1/p'))
	
	
	
	_SIZE=${#cpulist[@]}
	if [[ $SIZE -gt $_SIZE ]]
	then
		echo -e "${RED}Error${NC}: there are not as many GPUs as requested ($SIZE requested, $_SIZE exist(s))"
		exit
	fi	
	
	#TODO reorder cpulist by device name to match the order in DEVICES during constructing cpulist_expand
	
	cpulist_expand=()
	
	if [[ ! -z $BIND ]]
	then
	
		for index in ${!cpulist[*]}
		do
			tobeexpand=${cpulist[$index]}
			cpulist_expand+=($(range_expand $tobeexpand))
		done
	fi
}

get_cpu_dev_list $BIND

function get_env
{
	BIND=$1
	
	if [[ -z $BIND ]]
	then
		env="--mca mpi_warn_on_fork 0 --mca btl_smcuda_use_cuda_ipc 1 --mca mpi_common_cuda_cumemcpy_async 1 --bind-to none"
	else
		env="--mca mpi_warn_on_fork 0 --mca btl_smcuda_use_cuda_ipc 1 --mca mpi_common_cuda_cumemcpy_async 1"
	fi
}


get_env $BIND
##################
##################
# launching a rule
##################
##################

function BSP
{
	BSP_sync_type=$BSP_SYNC_TYPE
	if [[ -z $BSP_sync_type ]]
	then
	BSP_sync_type='cdd'
	fi
	
	BSP_exch_strategy=$BSP_EXCH_STRATEGY
	if [[ -z $BSP_exch_strategy ]]
	then
	BSP_exch_strategy='nccl32'
	fi
	
	args="$BSP_sync_type $BSP_exch_strategy $MODELFILE $MODELCLASS"

	

	command_array=()
	command_array+=('mpirun')

	for (( index=0; index<$SIZE; index++ ))
	do 
		command_array+=("$env -n 1 python -u $theanompipath/worker.py ${devarray[$index]} $args ${cpulist_expand[$index]}")
		if [[ $index -ne $((SIZE-1)) ]]
		then
			command_array+=(":")
		fi
	done

	echo
	echo "Theano-MPI started $SIZE BSP($BSP_sync_type,$BSP_exch_strategy) workers"
	echo "by executing: ${command_array[@]/#/}"
	
	${command_array[@]/#/}
	
}

function EASGD
{
	
	args="$MODELFILE $MODELCLASS"


	
	command_array=()
	command_array+=('mpirun')
	
	for index in ${!cpulist_expand[*]}
	do 
		if [[ $index -eq 0 ]] 
		then
			# the first device will correspond to the server
			file='easgd_server.py'
		else
			file='easgd_worker.py'
		fi
		command_array+=("$env -n 1 python -u $theanompipath/$file ${devarray[$index]} $args ${cpulist_expand[$index]}")
		if [[ $index -ne $((SIZE-1)) ]]
		then
			command_array+=(":")
		fi
	done
	
	echo
	echo "Theano-MPI started one EASGD server and ${SIZE-1} EASGD workers"
	echo "by executing: ${command_array[@]/#/}"
	
	${command_array[@]/#/}
	
}

function GOSGD
{
	
	args="$MODELFILE $MODELCLASS"


	command_array=()
	command_array+=('mpirun')

	for index in ${!cpulist_expand[*]}
	do 
		command_array+=("$env -n 1 python -u $theanompipath/gosgd_worker.py ${devarray[$index]} $args ${cpulist_expand[$index]}")
		if [[ $index -ne $((SIZE-1)) ]]
		then
			command_array+=(":")
		fi
	done

	echo
	echo "Theano-MPI started $SIZE GOSGD workers"
	echo "by executing: ${command_array[@]/#/}"
	
	${command_array[@]/#/}
	
	
}



case $RULE in
    'BSP')
	BSP 
    ;;
    'EASGD')
	EASGD 
    ;;
    'GOSGD')
	GOSGD
    ;;
    *)
        # unknown option
		echo -e "${RED}Error${NC}: unknown rule ${RULE}"
		exit 1
    ;;
esac